# Архитектурное решение по трейсингу

- [Архитектурное решение по трейсингу](#архитектурное-решение-по-трейсингу)
    - [Анализ системы](#анализ-системы)
    - [Мотивация](#мотивация)
      - [Для технической команды](#для-технической-команды)
      - [Для бизнеса](#для-бизнеса)
    - [Предлагаемое решение](#предлагаемое-решение)
    - [Компромиссы](#компромиссы)
    - [Аспекты безопасности](#аспекты-безопасности)

### Анализ системы
Ключевые сервисы и потенциальные точки зависания:
1. Shop API
   - Приём заказа или файлов 3D-модели от пользователя
   - Возможны задержки при записи/чтении из Shop DB
2. CRM API
    - Операции подтверждения заказа, изменения статуса, взаимодействие с Shop DB и/или собственной БД (если выделится в будущем)
    - Потенциально может зависнуть при асинхронном обмене статусами с MES через Messages Queue (RabbitMQ)
3. MES API
   - Длительные операции расчёта цены изделия, работа с 3D-файлами (3D files storage), фиксация данных в MES DB
    - Высокая нагрузка на CPU, возможные задержки или ошибки в RabbitMQ при массовых расчётах
4. Messages Queue (RabbitMQ)
    - Может забиваться сообщениями, если CRM или MES не успевают их обрабатывать
5. 3D files storage (S3-based)
    - Загрузка/выгрузка больших 3D-файлов может быть точкой медленной сети или неожиданного сбоя

**Основная идея для трейсинга:** отследить полный «жизненный путь» заказа — начиная от момента, когда пользователь (или B2B-партнёр) создаёт заказ, и заканчивая выставлением статуса PRICE_CALCULATED/MANUFACTURING_APPROVED/... и далее до CLOSED.

Список ключевых данных, которые следует собирать в трейсинге:
1. Trace ID, Span ID, Parent Span ID — базовые поля для любого распределённого трейсинга
2. Метаданные о заказе (Order ID, если есть в контексте) и/или идентификатор сессии пользователя
3. Время начала и окончания каждого вызова (Shop API, CRM API, MES API, RabbitMQ publish/consume)
4. HTTP/AMQP заголовки, коды ошибок (4xx, 5xx), время отклика, объём данных (при загрузке 3D-моделей)
5. Ошибка / исключение (если операция завершается неуспешно)
6. Базовые ресурсы (CPU usage, memory usage) могут быть дополнительно связаны с трейсингом для сложных случаев, но в минимальном виде нужен хотя бы application-level trace

### Мотивация

#### Для технической команды
1. Ускоренная диагностика проблем: Когда заказ пропадает или меняется статус с опозданием, инженеры смогут быстро найти, на каком этапе цепочки (Shop → CRM → RabbitMQ → MES → DB) произошла задержка или ошибка
2. Сокращение времени восстановления (MTTR): Трейсинг даёт возможность увидеть, где узкое место (долгий запрос к БД, застопорившаяся очередь)
3. Оптимизация вычислений: В MES сложные расчёты 3D-моделей могут тормозить весь процесс. С помощью трейсинга команда поймёт, какие конкретно шаги занимают наибольшее время

#### Для бизнеса
1. Повышение удовлетворённости клиентов: Быстрее решаются проблемы с заказами и пропавшими статусами, сокращаются задержки
2. Уменьшение числа просроченных заказов: Трейсинг помогает фиксировать аномально долгие операции, что ведёт к своевременным действиям (увеличить ресурсы, оптимизировать код)
3. Повышение прозрачности и доверия B2B-партнёров: Можно отчитываться о времени полного цикла расчёта/производства и гарантировать определённый SLA

### Предлагаемое решение
1. Использовать OpenTelemetry (в качестве фреймворка сбора/генерации трейс-данных) и Jaeger как отдельныq инструменты для хранения и визуализации
2. В Shop API, CRM API, MES API добавить библиотеки OpenTelemetry (включая JaegerExporter) для автоматического проставления Trace/Span ID в заголовках
3. RabbitMQ: внедрить плагины/интеграции, которые прокидывают корневые заголовки (Trace ID) в сообщения, чтобы цепочка не рвалась

**Шаги реализации:**
1. Внедрить агентов/библиотеки OpenTelemetry во все три основных API (Shop, CRM, MES)
2. Инструментировать точки общения с RabbitMQ (publish/consume) — включать Trace ID в заголовок сообщения
3. Поставить Jaeger сервер для хранения и визуализации трейсов. В конфигурации указать, откуда Jaeger сам забирает трейс-данные

**Автоматический мониторинг процесса заказа и алертинг:**
1. Как только заказ создаётся в Shop API, генерируется Trace ID, который передаётся дальше в CRM/MES
2. В Jaeger можно строить Trace Search по Order ID, чтобы видеть полный путь
3. Алертинг: при превышении времени обработки (например, > X минут между статусами) можно на уровне трейсинг-коллектора либо интегрироваться с Prometheus/Grafana (через метрики трейсинга)

В итоге мы получаем автодоводку — если заказ слишком долго «болтается» между Shop и CRM, система генерирует алерт.

Схема взаимодейсвтия, включая алертинг, доступна по [ссылке](https://drive.google.com/file/d/1BLPll-I_Hu-SHWMi0AypVTMqXRWG7mZ8/view?usp=sharing)

### Компромиссы
1. Невозможность прозрачного трейсинга в проприетарных модулях: если у компании есть сторонние сервисы (например, платёжный шлюз без возможности вставить свой код), то придётся либо обходиться без трейсинга, либо договариваться с поставщиком
2. Дополнительная нагрузка на сеть и хранилище: трейсинг генерирует большое количество данных (особенно при высоком RPS). Придётся выделять ресурсы (диск, память) для хранения и анализа.
3. Затраты на доработку кода: нужно обновить все сервисы (Shop, CRM, MES), чтобы корректно прокидывать Trace ID, Span ID и тд
4. Сложность интеграции с RabbitMQ: придётся модифицировать publish/consume логику, чтобы не терять контекст трейсинга. Либо можно повременить с этой интеграцией
5. Логирование персональных данных: возможно, некоторые поля заказа (имя клиента, адрес) нельзя сохранять в трейсах. Нужно внимательно настроить sampling и redaction

### Аспекты безопасности
1. Аутентификация и роль «Поддержка»:
   - Вход в систему трейсинга (Jaeger UI) — только для сотрудников с учётной записью (LDAP / SSO / OAuth)
   - Можно ввести разграничение прав: например, лишь DevOps и разработчики видят полные детали спанов
2. Шифрование трафика:
    - Использовать HTTPS/TLS для передачи трейс-данных от сервисов к трейсинг-серверу, чтобы избежать утечек в открытом канале
3. Фильтрация чувствительных данных:
   - При формировании спанов не включать пользовательские пароли, платежные данные, личную информацию
   - Использовать механизмы redaction и/или не трейсить часть полей (sampling policy)
4. Внешний доступ
   - Сделать доступ к трейсинг-системе только внутри VPN/корпоративной сети, что снизит риск внешних атак. При необходимости внешнего доступа — организовать VPN-туннель или защищённый прокси.